import { ClientSession, Connection, Document, FilterQuery, Types } from 'mongoose';
import { DocumentType, RichModelType } from 'mongoose-typescript';
import { RequireExactlyOne } from 'type-fest';
import { Constructor, Paged } from './index';
export type IdType = string | Types.ObjectId;
export type NotDocument<T> = T & {
    toObject: never;
};
type BuildQueryField<T> = keyof T | [keyof T, string] | {
    s: keyof T;
    m: string;
};
interface IBuildQueryArguments<T extends object, M = object> {
    equalFields?: BuildQueryField<T>[];
    matchFields?: BuildQueryField<T>[];
    idFields?: BuildQueryField<T>[];
    betweenFields?: BuildQueryField<T>[];
    inFields?: BuildQueryField<T>[];
    query?: FilterQuery<M>;
}
export declare function makeMongoRegexp(str: string, options?: string): {
    $regex: string;
    $options: string;
};
export declare function toObjectId(id: IdType): Types.ObjectId;
export declare function mongoBetween<T>(data: T[]): {
    $lte?: T;
    $gte?: T;
};
type NumberOperator = RequireExactlyOne<{
    $eq: number;
    $gt: number;
    $gte: number;
    $lt: number;
    $lte: number;
    $ne: number;
}>;
export declare function parseNumberQuery(query: string): NumberOperator;
export declare function buildQuery<T extends object, M = object>(search: T, args: IBuildQueryArguments<T, M>): FilterQuery<M>;
export declare function withSession<T>(fn: (session: ClientSession) => Promise<T>, connection: Connection, session?: ClientSession | null): Promise<T>;
export declare function saveDocs(docs: Document[], connection: Connection, session?: ClientSession): Promise<void>;
export declare function findAndCount<TModel extends RichModelType<Constructor<any>>, TDocument = DocumentType<InstanceType<TModel>>>(model: TModel, query: object, skip: number, limit: number, queryHelper?: (query: ReturnType<TModel['find']>) => void): Promise<Paged<TDocument>>;
export {};
