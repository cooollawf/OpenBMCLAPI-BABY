"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAndCount = exports.saveDocs = exports.withSession = exports.buildQuery = exports.parseNumberQuery = exports.mongoBetween = exports.toObjectId = exports.makeMongoRegexp = void 0;
const is_1 = __importDefault(require("@sindresorhus/is"));
const bluebird_1 = __importDefault(require("bluebird"));
const lodash_1 = require("lodash");
const mongoose_1 = require("mongoose");
function makeMongoRegexp(str, options = 'i') {
    if ((0, lodash_1.isNil)(str))
        return str;
    return {
        $regex: (0, lodash_1.escapeRegExp)(str), $options: options,
    };
}
exports.makeMongoRegexp = makeMongoRegexp;
function toObjectId(id) {
    if (!id)
        throw new TypeError('id cannot be empty');
    if (typeof id === 'string')
        return new mongoose_1.Types.ObjectId(id);
    return id;
}
exports.toObjectId = toObjectId;
function mongoBetween(data) {
    return {
        $lte: (0, lodash_1.max)(data),
        $gte: (0, lodash_1.min)(data),
    };
}
exports.mongoBetween = mongoBetween;
function parseNumberQuery(query) {
    const regex = /^(?<op>[<>=!]=?)(?<num>-?\d+.?\d*?)$/;
    const opMap = {
        '=': '$eq',
        '==': '$eq',
        '>': '$gt',
        '>=': '$gte',
        '<': '$lt',
        '<=': '$lte',
        '!=': '$ne',
        '!': '$ne',
    };
    const match = query.match(regex);
    if (!match)
        throw new TypeError(`Invalid number query: ${query}`);
    const { op, num } = match.groups;
    return { [opMap[op]]: Number(num) };
}
exports.parseNumberQuery = parseNumberQuery;
function buildQuery(search, args) {
    if (!search)
        return {};
    if (!is_1.default.object(search))
        throw new TypeError('search must be an object');
    const query = (args.query ?? {});
    if (args.equalFields) {
        for (const field of args.equalFields) {
            const { s, m } = getFields(field);
            if (s in search && search[s] !== undefined) {
                query[m] = search[s];
            }
        }
    }
    if (args.matchFields) {
        for (const field of args.matchFields) {
            const { s, m } = getFields(field);
            if (s in search && search[s] !== undefined) {
                query[m] = makeMongoRegexp(search[s].toString());
            }
        }
    }
    if (args.idFields) {
        for (const field of args.idFields) {
            const { s, m } = getFields(field);
            if (s in search && search[s] !== undefined) {
                query[m] = toObjectId(search[s]);
            }
        }
    }
    if (args.betweenFields) {
        for (const field of args.betweenFields) {
            const { s, m } = getFields(field);
            if (s in search && search[s] !== undefined) {
                const d = search[s];
                if (!Array.isArray(d))
                    throw new TypeError(`${s} is not array, got ${search[s]}`);
                query[m] = mongoBetween(d);
            }
        }
    }
    if (args.inFields) {
        for (const field of args.inFields) {
            const { s, m } = getFields(field);
            if (s in search && search[s] !== undefined) {
                const d = search[s];
                if (!Array.isArray(d))
                    throw new TypeError(`${s} is not array, got ${search[s]}`);
                query[m] = { $in: d };
            }
        }
    }
    return query;
    function getFields(field) {
        let s;
        let m;
        if (typeof field === 'string') {
            s = m = field;
        }
        else if (Array.isArray(field)) {
            s = field[0];
            m = field[1];
        }
        else {
            s = field.s;
            m = field.m;
        }
        return { s, m };
    }
}
exports.buildQuery = buildQuery;
async function withSession(fn, connection, session) {
    if (session) {
        return fn(session);
    }
    session = await connection.startSession();
    let ret = undefined;
    await session.withTransaction(async (session) => {
        ret = await fn(session);
    });
    return ret;
}
exports.withSession = withSession;
async function saveDocs(docs, connection, session) {
    await withSession(async (session) => {
        for (const doc of docs) {
            await doc.save({ session });
        }
    }, connection, session);
}
exports.saveDocs = saveDocs;
async function findAndCount(model, query, skip, limit, queryHelper) {
    const q = model.find(query).skip(skip).limit(limit);
    if (queryHelper) {
        queryHelper(q);
    }
    return bluebird_1.default.props({
        data: q.exec(),
        count: model.countDocuments(query),
    });
}
exports.findAndCount = findAndCount;
//# sourceMappingURL=mongodb.js.map